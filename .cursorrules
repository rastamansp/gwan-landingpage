# Regras do Cursor - Gwan Landing Page

## PrincÃ­pios Fundamentais

### SOLID Principles
- **S**ingle Responsibility: Cada classe/funÃ§Ã£o deve ter uma Ãºnica responsabilidade
- **O**pen/Closed: Aberto para extensÃ£o, fechado para modificaÃ§Ã£o
- **L**iskov Substitution: Subtipos devem ser substituÃ­veis por seus tipos base
- **I**nterface Segregation: Interfaces especÃ­ficas sÃ£o melhores que interfaces genÃ©ricas
- **D**ependency Inversion: Dependa de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes concretas

### Clean Architecture
- **Entities**: Regras de negÃ³cio centrais (independentes de frameworks)
- **Use Cases**: Casos de uso da aplicaÃ§Ã£o (orquestraÃ§Ã£o de regras de negÃ³cio)
- **Interface Adapters**: Controllers, Gateways, Presenters
- **Frameworks & Drivers**: UI, Database, External Interfaces

### Use Case Pattern
- Cada funcionalidade deve ter um Use Case dedicado
- Use Cases devem ser independentes de frameworks
- Input/Output DTOs para cada Use Case
- Tratamento de erros especÃ­ficos por Use Case

## Estrutura de MÃ³dulos

### Frontend (React)
```
src/
â”œâ”€â”€ modules/                   # MÃ³dulos da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ auth/                  # MÃ³dulo de autenticaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ domain/            # Entidades e regras de negÃ³cio
â”‚   â”‚   â”œâ”€â”€ application/       # Use Cases
â”‚   â”‚   â”œâ”€â”€ infrastructure/    # ImplementaÃ§Ãµes concretas
â”‚   â”‚   â””â”€â”€ presentation/      # Componentes React
â”‚   â”œâ”€â”€ contact/               # MÃ³dulo de contato
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â””â”€â”€ presentation/
â”‚   â””â”€â”€ portfolio/             # MÃ³dulo de portfÃ³lio
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ application/
â”‚       â”œâ”€â”€ infrastructure/
â”‚       â””â”€â”€ presentation/
â”œâ”€â”€ shared/                    # CÃ³digo compartilhado
â”‚   â”œâ”€â”€ domain/                # Entidades compartilhadas
â”‚   â”œâ”€â”€ infrastructure/        # ImplementaÃ§Ãµes compartilhadas
â”‚   â””â”€â”€ presentation/          # Componentes compartilhados
â””â”€â”€ core/                      # ConfiguraÃ§Ãµes centrais
    â”œâ”€â”€ config/
    â”œâ”€â”€ utils/
    â””â”€â”€ types/
```

### Backend (NestJS)
```
src/
â”œâ”€â”€ modules/                  # MÃ³dulos da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ auth/                 # MÃ³dulo de autenticaÃ§Ã£o
â”‚   â”‚   â”œâ”€â”€ domain/           # Entidades e regras de negÃ³cio
â”‚   â”‚   â”œâ”€â”€ application/      # Use Cases
â”‚   â”‚   â”œâ”€â”€ infrastructure/   # RepositÃ³rios e serviÃ§os externos
â”‚   â”‚   â””â”€â”€ presentation/     # Controllers e DTOs
â”‚   â”œâ”€â”€ contact/              # MÃ³dulo de contato
â”‚   â”‚   â”œâ”€â”€ domain/
â”‚   â”‚   â”œâ”€â”€ application/
â”‚   â”‚   â”œâ”€â”€ infrastructure/
â”‚   â”‚   â””â”€â”€ presentation/
â”‚   â””â”€â”€ portfolio/            # MÃ³dulo de portfÃ³lio
â”‚       â”œâ”€â”€ domain/
â”‚       â”œâ”€â”€ application/
â”‚       â”œâ”€â”€ infrastructure/
â”‚       â””â”€â”€ presentation/
â”œâ”€â”€ shared/                   # CÃ³digo compartilhado
â”‚   â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ infrastructure/
â”‚   â””â”€â”€ presentation/
â””â”€â”€ core/                     # ConfiguraÃ§Ãµes centrais
    â”œâ”€â”€ config/
    â”œâ”€â”€ utils/
    â””â”€â”€ types/
```

## Regras de ImplementaÃ§Ã£o

### 1. Domain Layer (Entidades e Regras de NegÃ³cio)
```typescript
// âœ… Correto - Entidade com regras de negÃ³cio
export class Contact {
  constructor(
    private readonly id: string,
    private readonly name: string,
    private readonly email: string,
    private readonly message: string,
    private readonly createdAt: Date
  ) {
    this.validateEmail(email);
    this.validateMessage(message);
  }

  private validateEmail(email: string): void {
    if (!email.includes('@')) {
      throw new Error('Invalid email format');
    }
  }

  private validateMessage(message: string): void {
    if (message.length < 10) {
      throw new Error('Message too short');
    }
  }

  // Getters para acessar propriedades
  getEmail(): string { return this.email; }
  getName(): string { return this.name; }
}
```

### 2. Application Layer (Use Cases)
```typescript
// âœ… Correto - Use Case com responsabilidade Ãºnica
export class CreateContactUseCase {
  constructor(
    private readonly contactRepository: IContactRepository,
    private readonly emailService: IEmailService
  ) {}

  async execute(input: CreateContactInput): Promise<CreateContactOutput> {
    // 1. ValidaÃ§Ã£o de entrada
    this.validateInput(input);

    // 2. CriaÃ§Ã£o da entidade
    const contact = new Contact(
      generateId(),
      input.name,
      input.email,
      input.message,
      new Date()
    );

    // 3. PersistÃªncia
    await this.contactRepository.save(contact);

    // 4. NotificaÃ§Ã£o
    await this.emailService.sendNotification(contact);

    return {
      id: contact.getId(),
      success: true
    };
  }

  private validateInput(input: CreateContactInput): void {
    if (!input.name || !input.email || !input.message) {
      throw new Error('Missing required fields');
    }
  }
}
```

### 3. Infrastructure Layer (ImplementaÃ§Ãµes Concretas)
```typescript
// âœ… Correto - ImplementaÃ§Ã£o concreta da interface
export class ContactRepository implements IContactRepository {
  constructor(private readonly database: Database) {}

  async save(contact: Contact): Promise<void> {
    await this.database.contacts.create({
      id: contact.getId(),
      name: contact.getName(),
      email: contact.getEmail(),
      message: contact.getMessage(),
      createdAt: contact.getCreatedAt()
    });
  }

  async findById(id: string): Promise<Contact | null> {
    const data = await this.database.contacts.findUnique({ where: { id } });
    if (!data) return null;
    
    return new Contact(
      data.id,
      data.name,
      data.email,
      data.message,
      data.createdAt
    );
  }
}
```

### 4. Presentation Layer (Controllers/Components)
```typescript
// âœ… Correto - Controller focado apenas em apresentaÃ§Ã£o
@Controller('contact')
export class ContactController {
  constructor(
    private readonly createContactUseCase: CreateContactUseCase
  ) {}

  @Post()
  async createContact(@Body() dto: CreateContactDto): Promise<CreateContactResponse> {
    try {
      const result = await this.createContactUseCase.execute({
        name: dto.name,
        email: dto.email,
        message: dto.message
      });

      return {
        success: true,
        data: result
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }
}
```

## Regras de Nomenclatura

### Interfaces
- Prefixo `I` para interfaces: `IContactRepository`
- Sufixo `UseCase` para casos de uso: `CreateContactUseCase`
- Sufixo `Service` para serviÃ§os: `EmailService`
- Sufixo `Repository` para repositÃ³rios: `ContactRepository`

### Classes
- Nomes descritivos: `Contact`, `CreateContactUseCase`
- Evitar abreviaÃ§Ãµes: `ContactRepo` âŒ, `ContactRepository` âœ…

### Arquivos
- PascalCase para classes: `Contact.ts`
- camelCase para funÃ§Ãµes/utilitÃ¡rios: `contactUtils.ts`
- kebab-case para componentes: `contact-form.tsx`

## Regras de DependÃªncias

### DireÃ§Ã£o das DependÃªncias
```
Presentation â†’ Application â†’ Domain
Infrastructure â†’ Application â†’ Domain
```

### InversÃ£o de DependÃªncia
```typescript
// âœ… Correto - DependÃªncia de abstraÃ§Ã£o
export class CreateContactUseCase {
  constructor(
    private readonly contactRepository: IContactRepository, // Interface
    private readonly emailService: IEmailService // Interface
  ) {}
}

// âŒ Incorreto - DependÃªncia de implementaÃ§Ã£o concreta
export class CreateContactUseCase {
  constructor(
    private readonly contactRepository: ContactRepository, // ImplementaÃ§Ã£o
    private readonly emailService: EmailService // ImplementaÃ§Ã£o
  ) {}
}
```

## Regras de Testes

### Estrutura de Testes
```
tests/
â”œâ”€â”€ unit/                     # Testes unitÃ¡rios
â”‚   â”œâ”€â”€ domain/
â”‚   â”œâ”€â”€ application/
â”‚   â””â”€â”€ infrastructure/
â”œâ”€â”€ integration/              # Testes de integraÃ§Ã£o
â””â”€â”€ e2e/                      # Testes end-to-end
```

### PadrÃ£o de Testes
```typescript
// âœ… Correto - Teste focado em comportamento
describe('CreateContactUseCase', () => {
  it('should create contact successfully', async () => {
    // Arrange
    const mockRepository = createMockRepository();
    const mockEmailService = createMockEmailService();
    const useCase = new CreateContactUseCase(mockRepository, mockEmailService);
    
    // Act
    const result = await useCase.execute({
      name: 'John Doe',
      email: 'john@example.com',
      message: 'Hello world'
    });
    
    // Assert
    expect(result.success).toBe(true);
    expect(mockRepository.save).toHaveBeenCalled();
    expect(mockEmailService.sendNotification).toHaveBeenCalled();
  });
});
```

## Regras de Error Handling

### Domain Errors
```typescript
// âœ… Correto - Erros especÃ­ficos do domÃ­nio
export class InvalidEmailError extends Error {
  constructor(email: string) {
    super(`Invalid email format: ${email}`);
    this.name = 'InvalidEmailError';
  }
}

export class MessageTooShortError extends Error {
  constructor(minLength: number) {
    super(`Message must be at least ${minLength} characters`);
    this.name = 'MessageTooShortError';
  }
}
```

### Use Case Error Handling
```typescript
// âœ… Correto - Tratamento especÃ­fico de erros
export class CreateContactUseCase {
  async execute(input: CreateContactInput): Promise<CreateContactOutput> {
    try {
      // LÃ³gica do use case
    } catch (error) {
      if (error instanceof InvalidEmailError) {
        return { success: false, error: 'Invalid email format' };
      }
      if (error instanceof MessageTooShortError) {
        return { success: false, error: 'Message too short' };
      }
      throw error; // Re-throw erros nÃ£o tratados
    }
  }
}
```

## Regras de Performance

### Lazy Loading
- Use lazy loading para mÃ³dulos grandes
- Implemente code splitting por rota
- Carregue dados sob demanda

### Caching
- Cache de dados frequentemente acessados
- Implemente cache de consultas
- Use React Query para cache no frontend

### OtimizaÃ§Ãµes
- Evite re-renders desnecessÃ¡rios
- Use React.memo para componentes pesados
- Implemente virtualizaÃ§Ã£o para listas grandes

## Regras de SeguranÃ§a

### ValidaÃ§Ã£o
- Valide todas as entradas no backend
- Use class-validator para DTOs
- Sanitize dados antes de persistir

### AutenticaÃ§Ã£o
- Implemente JWT com refresh tokens
- Use bcrypt para senhas
- Implemente rate limiting

### AutorizaÃ§Ã£o
- Use guards para proteger rotas
- Implemente role-based access control
- Valide permissÃµes em use cases

## Regras de DocumentaÃ§Ã£o

### ComentÃ¡rios
- Documente regras de negÃ³cio complexas
- Explique algoritmos nÃ£o Ã³bvios
- Documente APIs pÃºblicas

### README
- Mantenha README atualizado
- Documente setup do projeto
- Inclua exemplos de uso

### API Documentation
- Use Swagger/OpenAPI
- Documente todos os endpoints
- Inclua exemplos de request/response

## ğŸ”§ PadrÃµes de API REST ObrigatÃ³rios

### Estrutura PadrÃ£o de Resposta

**TODAS as APIs devem seguir estes padrÃµes obrigatÃ³rios:**

#### Sucesso (200)
```json
{
  "success": true,
  "message": "OperaÃ§Ã£o realizada com sucesso",
  "data": {
    // Dados especÃ­ficos da operaÃ§Ã£o
  }
}
```

#### Erro (400, 401, 403, 404, 500)
```json
{
  "success": false,
  "message": "DescriÃ§Ã£o do erro",
  "error": "CÃ³digo do erro (opcional)"
}
```

### Campos Padronizados ObrigatÃ³rios

#### UsuÃ¡rio
- **SEMPRE** usar `user` (nÃ£o `userData`, `userInfo`, etc.)
- **Estrutura consistente**:
```json
{
  "id": "string",
  "name": "string", 
  "email": "string",
  "phone": "string",
  "status": "string"
}
```

#### AutenticaÃ§Ã£o
- **SEMPRE** usar `token` (nÃ£o `jwt`, `accessToken`, etc.)
- **SEMPRE** usar `userId` (nÃ£o `id`, `user_id`, etc.)
- **SEMPRE** usar `activationCode` e `loginCode`

#### Upload
- **SEMPRE** usar `imageUrl` (nÃ£o `url`, `image_url`, etc.)

### Status Codes HTTP Padronizados

- **200**: Sucesso
- **201**: Criado com sucesso  
- **400**: Erro de validaÃ§Ã£o/requisiÃ§Ã£o
- **401**: NÃ£o autorizado
- **403**: Acesso negado
- **404**: Recurso nÃ£o encontrado
- **500**: Erro interno do servidor

### ValidaÃ§Ã£o de Entrada Padronizada

#### DTOs Padronizados
```typescript
export class RegisterUserDto {
  @IsString()
  name: string;

  @IsEmail()
  email: string;

  @IsString()
  phone: string;
}
```

#### ValidaÃ§Ã£o de Arquivos
```typescript
export class UploadFileDto {
  @IsFile()
  @MaxFileSize(20 * 1024 * 1024) // 20MB
  @FileType(['image/jpeg', 'image/png', 'image/gif'])
  file: Express.Multer.File;
}
```

### DocumentaÃ§Ã£o Swagger Padronizada

```typescript
@ApiOperation({ summary: 'DescriÃ§Ã£o da operaÃ§Ã£o' })
@ApiResponse({
  status: 200,
  description: 'Sucesso',
  schema: {
    type: 'object',
    properties: {
      success: { type: 'boolean', example: true },
      message: { type: 'string', example: 'OperaÃ§Ã£o realizada' },
      // outros campos...
    },
  },
})
@ApiResponse({
  status: 400,
  description: 'Erro de validaÃ§Ã£o',
  schema: {
    type: 'object',
    properties: {
      success: { type: 'boolean', example: false },
      message: { type: 'string', example: 'Erro de validaÃ§Ã£o' },
    },
  },
})
```

### Logs Padronizados

```typescript
this.logger.log(`OperaÃ§Ã£o para usuÃ¡rio: ${userId}`);
this.logger.error(`Erro na operaÃ§Ã£o: ${error.message}`);
```

### SeguranÃ§a Padronizada

#### Headers ObrigatÃ³rios
- **Authorization**: `Bearer <token>` para rotas protegidas
- **Content-Type**: `application/json` para JSON
- **Content-Type**: `multipart/form-data` para uploads

#### ValidaÃ§Ã£o de Token
- **SEMPRE** validar token em rotas protegidas
- **SEMPRE** retornar 401 para tokens invÃ¡lidos
- **SEMPRE** incluir informaÃ§Ãµes do usuÃ¡rio no token JWT

### Performance Padronizada

#### Cache
- **SEMPRE** usar cache para dados frequentemente acessados
- **SEMPRE** invalidar cache quando dados sÃ£o modificados

#### Rate Limiting
- **SEMPRE** implementar rate limiting em endpoints sensÃ­veis
- **SEMPRE** retornar 429 quando limite Ã© excedido

### Monitoramento Padronizado

#### MÃ©tricas
- **SEMPRE** registrar tempo de resposta
- **SEMPRE** registrar taxa de erro
- **SEMPRE** registrar uso de recursos

#### Alertas
- **SEMPRE** configurar alertas para erros crÃ­ticos
- **SEMPRE** configurar alertas para performance degradada

### Exemplos de Endpoints Padronizados

#### AutenticaÃ§Ã£o
```typescript
// POST /auth/register
{
  "success": true,
  "userId": "user_123",
  "message": "UsuÃ¡rio registrado com sucesso",
  "activationCode": "123456"
}

// POST /auth/activate/:userId
{
  "success": true,
  "message": "UsuÃ¡rio ativado com sucesso",
  "token": "jwt-token",
  "user": {
    "id": "user_123",
    "name": "John Doe",
    "email": "john@example.com",
    "phone": "+5511999999999",
    "status": "ACTIVE"
  }
}
```

#### Upload
```typescript
// POST /upload
{
  "success": true,
  "imageUrl": "https://storage.example.com/users/user-123/image.jpg",
  "message": "Imagem do personagem enviada com sucesso!"
}
```

## Regras de Deploy

### Environment Variables
- Use .env para configuraÃ§Ãµes
- Nunca commite secrets
- Valide variÃ¡veis obrigatÃ³rias

### Build Process
- Otimize builds de produÃ§Ã£o
- Implemente CI/CD
- Use Docker para consistÃªncia

### Monitoring
- Implemente logging estruturado
- Use health checks
- Monitore performance

## Regras de Qualidade e ValidaÃ§Ã£o

### Obrigatoriedade de Lint, Build e Testes
- **ANTES DE CADA COMMIT**: Execute `npm run lint` e garanta ZERO erros
- **ANTES DE CADA PUSH**: Execute `npm run build` e garanta ZERO erros
- **ANTES DE CADA PUSH**: Execute `npm run test` e garanta TODOS os testes passando
- **ANTES DE CADA MERGE**: Execute `npm run test` e garanta todos os testes passando
- **SEMPRE**: Valide se o projeto roda com `npm run dev` antes de commitar

### Regra de Deploy - Apenas com Testes e Lint OK
- **NUNCA FAÃ‡A DEPLOY** se os testes nÃ£o estiverem passando
- **NUNCA FAÃ‡A DEPLOY** se o lint nÃ£o estiver OK
- **SEMPRE EXECUTE** `npm run lint && npm run test` antes de qualquer deploy
- **SEMPRE VERIFIQUE** que nÃ£o hÃ¡ erros de build antes do deploy
- **SE HOUVER ERROS**: Corrija TODOS os erros antes de fazer deploy
- **DEPLOY SÃ“ APÃ“S**: Todos os testes passando + Lint OK + Build OK

### ImportÃ¢ncia dos Testes UnitÃ¡rios
- **TESTES SÃƒO OBRIGATÃ“RIOS**: Nunca suba cÃ³digo sem testes passando
- **COBERTURA MÃNIMA**: Mantenha cobertura de testes acima de 80%
- **TESTES ANTES DE COMMIT**: Execute testes antes de cada commit
- **TESTES ANTES DE PUSH**: Execute testes antes de cada push
- **TESTES ANTES DE MERGE**: Execute testes antes de cada merge
- **TESTES QUEBRADOS = BUG**: Se testes quebram, corrija antes de continuar
- **TESTES COMO DOCUMENTAÃ‡ÃƒO**: Testes devem documentar comportamento esperado
- **TESTES COMO REFATORAÃ‡ÃƒO**: Use testes para validar refatoraÃ§Ãµes

### Checklist de Qualidade

Antes de commitar:
- [ ] CÃ³digo segue princÃ­pios SOLID
- [ ] Use Cases implementados corretamente
- [ ] **LINT**: `npm run lint` sem erros
- [ ] **BUILD**: `npm run build` sem erros
- [ ] **DEV**: `npm run dev` roda sem problemas
- [ ] **TESTES**: `npm run test` - TODOS os testes passando
- [ ] **COBERTURA**: Cobertura de testes acima de 80%
- [ ] DocumentaÃ§Ã£o atualizada
- [ ] Performance aceitÃ¡vel
- [ ] SeguranÃ§a implementada
- [ ] Error handling adequado
- [ ] **API REST**: PadrÃµes de resposta seguidos
- [ ] **CAMPOS PADRONIZADOS**: `user`, `token`, `userId`, `imageUrl` usados corretamente

### Comandos ObrigatÃ³rios
```bash
# Antes de cada commit
npm run lint          # Deve retornar ZERO erros
npm run build         # Deve retornar ZERO erros
npm run test          # TODOS os testes devem passar (execuÃ§Ã£o Ãºnica)
npm run dev           # Deve rodar sem problemas

# Antes de cada push
npm run test          # Todos os testes devem passar (execuÃ§Ã£o Ãºnica)
npm run test:coverage # Verificar cobertura de testes

# Antes de cada merge
npm run test          # Todos os testes devem passar (execuÃ§Ã£o Ãºnica)
npm run test:coverage # Verificar cobertura de testes

# Comandos individuais para desenvolvimento
npm run test:frontend # Testes do frontend apenas (execuÃ§Ã£o Ãºnica)
npm run test:backend  # Testes do backend apenas (execuÃ§Ã£o Ãºnica)
```

### Regras de Commit
- Use conventional commits: `feat:`, `fix:`, `docs:`, `style:`, `refactor:`, `test:`, `chore:`
- Mensagens em portuguÃªs
- Descreva claramente a mudanÃ§a
- Exemplo: `feat: implementa sistema de autenticaÃ§Ã£o em 3 passos` 